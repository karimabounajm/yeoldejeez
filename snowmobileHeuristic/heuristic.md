# problem definition
so essentially, we are searching for the path with the least number of collisions, given that following every instance of motion, the sleigh dude has a chance to adjust the motion. possible paths are by ratios of whole numbers, so a / b meaning we go a right and b down, given that a + b == 4 and santie claus must go down at least one unit in every instance. after finding this path, print out the map and show the big man's path down da mountain, with character Î± representing the god himself.

# general heuristic strategy
to avoid the time drain of recursively going down every branch for every transformation, we can instead check at every node if the number of collisions is greater than the number of collisions on the path with the fewest. 

this can be achieved by the creation of two structs, each with two variables. STR_PATH, which is a string of all the transformations taken in reaching this node in this recursive call; this can be done as a series of coordinates, with the transformation taken being obvious based on the change of values. NUM_COL, for a comparison of the number of collisions in the current path and the least number of collisions.

one struct instance should be for the path with the least number of collisions (thus far). its string of transformations will used to print the final gamepath. The number of collisions will be compared at every node with the number of collisions in the current path. another struct instance will be the current path the recursion is being taken.  its string of transformations will be used for backpropagation, as when we reach a node where the number of collisions exceeds the least number in the other struct, we revert back to the previous position and try every other transformation until either a new path the least number of collisions is reached, or every transformation is tried and we move one node further up the string.

essentially, at every instance comparae current number of collisions with the least number of collisions, which will always start as the number of collisions when we go down a uniform set of transitions (let's start the recursive callings with 3 right one down, so the number of collisions would be the number of collisions if we went down the slope using only 3 right 1 down). From there, if the path we're on exceeds that value, go back one and than continue down every other transformation until they themselves either update the path of least collisions (unlikely but possible, should account for it) or we do other transformations. We'll continue doing this until every transformation and every path FROM THIS NODE have been attempted, then we move up it again. backpropagation/nearest neighbour?? according to mama.
